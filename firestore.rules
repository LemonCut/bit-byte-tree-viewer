/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant data model where users own their data under `/users/{userId}`.
 * Trees, Bytes, and Connections are managed as top-level collections and subcollections, respectively, without explicit ownership.
 * Admin privileges are granted based on the presence of a document in the `/roles_admin/{userId}` collection.
 * The rules prioritize strict authorization and data access control while maintaining flexibility in data shapes for rapid prototyping.
 *
 * Data Structure:
 * - /users/{userId}: User-specific data. Only the authenticated user can access their own data.
 * - /trees/{treeId}: Collection of trees.  Access is not explicitly restricted in this initial version.
 * - /trees/{treeId}/bytes/{byteId}: Subcollection of bytes associated with a specific tree.
 * - /connections/{connectionId}: Collection of all connections.
 * - /roles_admin/{userId}: Documents indicating admin roles. Existence implies admin privileges.
 *
 * Key Security Decisions:
 * - User listing is disallowed for privacy.
 * - The rules avoid complex `get()` operations by relying on path-based authorization and role checks.
 * - The security posture defaults to strict: if a permission is not explicitly granted, it is denied.
 *
 * Denormalization for Authorization:
 *  - The Byte and Connection entities include a `treeId` field, denormalized from the parent `Tree` document.
 *    This allows for authorization checks on Bytes and Connections without requiring a `get()` on the parent `Tree`.
 *
 * Structural Segregation:
 * - User data is segregated under the `/users/{userId}` path to ensure private access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the document.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user has admin privileges based on the existence of a document in /roles_admin/{userId}.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rules for user-specific data.
     * @path /users/{userId}
     * @allow (create) User with UID 'user_abc' can create their own document at /users/user_abc.
     * @deny (create) User with UID 'user_abc' cannot create a document at /users/user_xyz.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for trees collection.
     * @path /trees/{treeId}
     * @allow (get) Any signed-in user can read a tree.
     * @deny (create) Non-admin users cannot create trees
     * @principle Allows public read access but restricts write access to admins.
     */
    match /trees/{treeId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for bytes subcollection.
     * @path /trees/{treeId}/bytes/{byteId}
     * @allow (create) Any signed-in user can create a byte under a tree.
     * @deny (update) Non-admin users cannot update bytes.
     * @principle Restricts write access to admins.
     */
    match /trees/{treeId}/bytes/{byteId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for connections subcollection.
     * @path /connections/{connectionId}
     * @allow (create) Any signed-in user can create a connection under a tree.
     * @deny (update) Non-admin users cannot update connections.
     * @principle Restricts write access to admins.
     */
    match /connections/{connectionId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

     /**
      * @description Rules for the admin role.
      * @path /roles_admin/{userId}
      * @allow (create) Only the user themselves can create their admin role document.
      * @deny (delete) Only the user themselves can delete their admin role document.
      * @principle This enforces that only the authenticated user can manage their own admin role.
      */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }
  }
}

    