{
  "entities": {
    "Tree": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tree",
      "type": "object",
      "description": "Represents a tree within the organization, defining a specific hierarchical structure.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Tree entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the tree (e.g., 'Alpha Tree', 'Beta Tree')."
        },
        "description": {
          "type": "string",
          "description": "A description of the tree, providing additional context."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "Byte": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Byte",
      "type": "object",
      "description": "Represents a 'byte' or individual within the tree.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Byte entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the byte."
        },
        "treeId": {
          "type": "string",
          "description": "Reference to Tree. (Relationship: Tree 1:N Byte)"
        }
      },
      "required": [
        "id",
        "name",
        "treeId"
      ]
    },
    "Connection": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Connection",
      "type": "object",
      "description": "Represents a connection between two bytes (big and little) within a tree.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Connection entity."
        },
        "bigId": {
          "type": "string",
          "description": "Reference to the 'big' Byte in the connection. (Relationship: Byte 1:N Connection)"
        },
        "littleId": {
          "type": "string",
          "description": "Reference to the 'little' Byte in the connection. (Relationship: Byte 1:N Connection)"
        },
        "yearOfPickup": {
          "type": "number",
          "description": "The year in which the connection was established."
        }
      },
      "required": [
        "id",
        "bigId",
        "littleId",
        "yearOfPickup"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous",
      "google.com"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "user",
          "schema": {
            "$ref": "#/backend/entities/user"
          },
          "description": "Path for storing user-specific data.  Access is restricted to the authenticated user via `request.auth.uid == userId`.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, matching the Firebase Auth UID."
            }
          ]
        }
      },
      {
        "path": "/trees/{treeId}",
        "definition": {
          "entityName": "Tree",
          "schema": {
            "$ref": "#/backend/entities/Tree"
          },
          "description": "Collection of trees within the organization.  Access control can be managed at the tree level (e.g., via a members subcollection, not implemented in this basic design).",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the tree."
            }
          ]
        }
      },
      {
        "path": "/trees/{treeId}/bytes/{byteId}",
        "definition": {
          "entityName": "Byte",
          "schema": {
            "$ref": "#/backend/entities/Byte"
          },
          "description": "Subcollection of bytes associated with a specific tree. Includes denormalized 'treeId' for authorization independence.",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the tree."
            },
            {
              "name": "byteId",
              "description": "The unique identifier for the byte."
            }
          ]
        }
      },
      {
        "path": "/trees/{treeId}/connections/{connectionId}",
        "definition": {
          "entityName": "Connection",
          "schema": {
            "$ref": "#/backend/entities/Connection"
          },
          "description": "Subcollection of connections associated with a specific tree. Includes denormalized 'treeId' for authorization independence.",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the tree."
            },
            {
              "name": "connectionId",
              "description": "The unique identifier for the connection."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "admin",
          "schema": {
            "$ref": "#/backend/entities/user"
          },
          "description": "Indicates admin role via document existence. No content is required. Use existence checks in rules. DBAC.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to address the 'auth/operation-not-allowed' error, which typically indicates an issue with Firebase Authentication settings or usage. Since the error arises from Firebase Auth, the structure focuses on securely managing user-related data and roles without direct database-enforced access control (DBAC) for authentication operations themselves. The recommended setup includes path-based ownership for user-specific data and separate collections for entities with more complex access control needs. No custom claims are used, as per the instructions; user roles/access are determined by the existence of documents in specific role collections (DBAC via document existence).  Authorization independence is achieved by avoiding `get()` calls in security rules and relying on path-based ownership and explicit role checks. Segregation ensures that each collection has homogeneous security requirements.\n\nThe structure supports QAPs via:\n\n1.  **Path-based ownership for users:**  The `/users/{userId}` path ensures that only the authenticated user can access their specific data.\n2.  **Tree ownership:** The `/trees/{treeId}` path allows for centralized management and potentially broader access control (e.g., via a 'members' subcollection with role-based access, if required in the future).\n3.  **Byte and Connection data segregation within trees:** Storing Bytes and Connections under the `/trees/{treeId}` path provides a clear hierarchy and enables efficient querying and listing of these entities within a specific tree context.\n\nThis design facilitates debugging by making authorization intent explicit in the path structure and security rules. The absence of complex dependencies and the clear separation of concerns contribute to a more maintainable and secure application."
  }
}