{
  "entities": {
    "Tree": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tree",
      "type": "object",
      "description": "Represents a tree within the organization.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Tree entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the tree."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "Byte": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Byte",
      "type": "object",
      "description": "Represents a byte in the tree hierarchy.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Byte entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the byte."
        },
        "treeId": {
          "type": "string",
          "description": "Reference to Tree. (Relationship: Tree 1:N Byte)"
        }
      },
      "required": [
        "id",
        "name",
        "treeId"
      ]
    },
    "Connection": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Connection",
      "type": "object",
      "description": "Represents a connection between two bytes (big and little).",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Connection entity."
        },
        "bigId": {
          "type": "string",
          "description": "Reference to Byte (the 'big' in the connection)."
        },
        "littleId": {
          "type": "string",
          "description": "Reference to Byte (the 'little' in the connection)."
        },
        "yearOfPickup": {
          "type": "number",
          "description": "The year the connection was established."
        }
      },
      "required": [
        "id",
        "bigId",
        "littleId",
        "yearOfPickup"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/trees/{treeId}",
        "definition": {
          "entityName": "Tree",
          "schema": {
            "$ref": "#/backend/entities/Tree"
          },
          "description": "Stores tree data. Includes denormalized fields (if any) to support Authorization Independence.",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the tree."
            }
          ]
        }
      },
      {
        "path": "/trees/{treeId}/bytes/{byteId}",
        "definition": {
          "entityName": "Byte",
          "schema": {
            "$ref": "#/backend/entities/Byte"
          },
          "description": "Stores byte data. Includes 'treeId' to enable list operations scoped to a specific tree. Includes denormalized fields (if any) to support Authorization Independence.",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the parent tree."
            },
            {
              "name": "byteId",
              "description": "The unique identifier for the byte."
            }
          ]
        }
      },
      {
        "path": "/trees/{treeId}/connections/{connectionId}",
        "definition": {
          "entityName": "Connection",
          "schema": {
            "$ref": "#/backend/entities/Connection"
          },
          "description": "Stores connection data between bytes within a tree. Includes denormalized 'treeId' to allow for atomic security rules. Includes 'bigId', 'littleId' and 'yearOfPickup'.",
          "params": [
            {
              "name": "treeId",
              "description": "The unique identifier for the parent tree."
            },
            {
              "name": "connectionId",
              "description": "The unique identifier for the connection."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to provide a secure and scalable solution for the TreeView application, focusing on clear authorization and data integrity. The design emphasizes Authorization Independence, eliminating the need for `get()` calls in security rules, which is crucial for atomic operations and debuggability. Structural Segregation ensures that collections have homogeneous security needs, simplifying rule creation.\n\nThe `trees` collection stores the basic information about each tree. Access control is not specified, but this can be expanded to include ownership or membership if required. The `bytes` subcollection under each tree stores individual byte data. Critically, each byte document includes the `treeId` to maintain a direct link to the parent tree for easy querying and to enable list operations scoped to a specific tree. The `connections` subcollection, nested under each tree, stores the connections between bytes within that tree. Each connection document includes `bigId`, `littleId`, and `yearOfPickup`. This structure allows for efficient querying of connections within a specific tree and direct enforcement of data integrity rules at the connection level, all while avoiding `get()` calls in security rules by denormalizing the `treeId` into the connection document.\n\nThis design facilitates simple, robust, and easily debuggable security rules because authorization checks can be performed directly on the requested document without needing to traverse the document hierarchy."
  }
}